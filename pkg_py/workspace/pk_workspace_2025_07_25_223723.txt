
"""
"""Save text to the corresponding history file."""
"""flag ê°’ì´ Trueê°€ ë˜ë©´ íŠ¹ì • ìž‘ì—… ìˆ˜í–‰ í›„ ë‹¤ì‹œ Falseë¡œ ì´ˆê¸°í™”"""
"""ì‚¬ìš©ìžê°€ Enter í‚¤ë¥¼ ìž…ë ¥í•˜ë©´ flagë¥¼ Trueë¡œ ì„¤ì •"""
"# .gitignore",
".git",
".gitignore",
".idea",
".venv",
"__pycache__",
"add: new feature for ~~",
"chore: update dependencies",
"chore: various improvements and updates across multiple files",
"docs: update README.md and improved project documentation",
"feat: add user profile page",
"fix: resolve issue with ~~",
"found: problem",
"pk_system.egg-info",
"refactor: improve code readability in user module",
"refactor: improve code readability in ~~",
"refactor: restructure and update multiple files with improved messages and translations",
#
#             "add: new feature for ~~",
#             "chore: update dependencies",
#             "chore: various improvements and updates across multiple files",
#             "docs: update README.md and improved project documentation",
#             "feat: add user profile page",
#             "fix: resolve issue with ~~",
#             "refactor: improve code readability in user module",
#             "refactor: improve code readability in ~~",
#             "refactor: restructure and update multiple files with improved messages and translations",
#             f"feat: auto pushed (made savepoint) by {SCRIPT_NAME} at {get_time_as_("%Y-%m-%d %H:%M")}",
#     base_dir = os.path.abspath(os.path.dirname(__file__))
#     history_file = os.path.join(__file__, f"{func_n}.history")
#     return
#     return history_file
# 0. git config set
# 1. git add
# 2. git commit
# 3. git push
# OSë³„ ì‹¤í–‰
# WSL í™˜ê²½
# based on from types import ModuleType
# cmd_exe_titleì´ í”„ë¡œì„¸ìŠ¤ cmdlineì— í¬í•¨ë˜ì–´ ìžˆëŠ”ì§€ í™•ì¸
# cmd_to_os(f'taskkill /f /pid {pid}', debug_mode=debug_mode)
# debug_this_code_operated(ipdb)
# def get_last_history_file(__file__, func_n):
# editable = False
# ensure_pk_system_exit_silent()
# exec í•  ëª…ë ¹
# f_nx = f_nx
# first call ì—ì„œ optionsì— ê°’ì„ ë„£ê³ , ì´í›„ í˜¸ì¶œë¶€í„°ëŠ” init_options = [] ë¡œ í•´ì•¼í•¨, ê³„ì† ê°’ì´ ë”í•´ì§
# function_arg_names= [param.name for param in inspect.signature(process_kill).parameters.values()] # fail
# git commit msg templates
# if not is_window_opened_exactly(window_title=window_title):
# ipdb.set_trace()  # ðŸ” ë””ë²„ê¹… ì‹œìž‘ ì§€ì 
# main loop run
# not recommanded way
# os.system(command=rf"call {DEST_DIR}\pk_push_project_to_github.bat")
# pk_kill_process_v1(window_title)
# pk_kill_process_v16(window_title, exact=True)
# pk_print(f"[PROCESS TERMINATED] PID={pid}, Name={process.info['name']}")
# pk_print(f"[SKIP] ì°½ ì œëª© ì„¸ê·¸ë¨¼íŠ¸ '{cmd_exe_title}'ë¡œ ì°¾ì€ ì°½ì´ ì—†ìŠµë‹ˆë‹¤.", print_color="blue")
# pk_print(f'''{PkMessages2025.NOT_PREPARED_YET}{'%%%FOO%%%' if LTA else ''}''', print_color='green', mode_verbose=0) # write code here
# pk_sleep(milliseconds=1000)
# pk_sleep(seconds=1000)
# pk_sleep(seconds=500)
# pk_system_kill_us_keyboard.cmd (run)
# return text.encode('cp949', errors='replace').decode('cp949')
# shm.unlink()  # ì£¼ì„ í•´ì œí•˜ë©´ ê³µìœ  ë©”ëª¨ë¦¬ ì‚­ì œë¨ (í”„ë¡œì„¸ìŠ¤ ê°„ ê³µìœ  ìœ ì§€í•˜ë ¤ë©´ ìœ ì§€)
# sleep
# sys.stdout.reconfigure(encoding='utf-8') # fail
# thread run (in background)
# title ëª…ë ¹ì–´ë¡œ ì°½ ì œëª© ì§€ì • (pk_ ì ‘ë‘ì‚¬ ì œê±°ëœ ì œëª©)
# user input hard cording, autocomplete, fzf, history file
# user input history, autocomplete, fzf, history file
# values = values.replace('â€“', '-')  # ìœ ë‹ˆì½”ë“œ EN DASH â†’ í•˜ì´í”ˆ
# â‘  ì—´ë¦° ì°½ ëª©ë¡ í™•ë³´ ë° CP949 ëŒ€ì‘ ì²˜ë¦¬
# â‘¡ ì œëª©ë³„ë¡œ ê·¸ë£¹í•‘ (ìœˆë„ìš° ì œëª© ê¸°ì¤€)
# â‘¢ ê° ì œëª©ì— ëŒ€í•´ 1ê°œë§Œ ë‚¨ê¸°ê³  ë‹«ê¸° ì‹œë„
# âœ… ì¢…ë£Œ ì „ì— ì‹¤í–‰
# ê³µìœ  ë©”ëª¨ë¦¬ í•´ì œ (í•„ìš”í•˜ë©´ exec )
# ê¸°ì¡´ ê³µìœ  ë©”ëª¨ë¦¬ ì¡´ìž¬ ì—¬ë¶€ í™•ì¸
# ê¸°íƒ€ ë¦¬ëˆ…ìŠ¤/ìœ ë‹‰ìŠ¤
# ë””ë ‰í† ë¦¬ ì œì™¸
# ë¬¸ìžì—´ ì „ì²˜ë¦¬
# ìŠ¤ë ˆë“œ ì¢…ë£Œ
# ìœ ì‚¬ ë¬¸ìž ìˆ˜ë™ ì¹˜í™˜
# ìœ ì‚¬ë„ ë†’ì€ ì²« ë²ˆì§¸ íƒ€ì´í‹€ë¡œ ì„ íƒ
# ì „ì—­ ìŠ¤í… ì¹´ìš´í„°
# ì „ì—­ ìŒì„± í ë° ìž¬ìƒ ì“°ë ˆë“œ (ì´ˆê¸°í™” 1íšŒë§Œ)
# ì œì™¸í•  íŒŒì¼/ë””ë ‰í† ë¦¬ ì´ë¦„
# ì¢…ë£Œí•  ìŠ¤ë ˆë“œ ì´ë¦„
# ì¢…ë£Œí•  ìŠ¤ë ˆë“œ ì°¾ê¸°
# ì¦‰ì‹œ ëª¨ë“œ: ê¸°ì¡´ ìž¬ìƒ ì¤‘ë‹¨ í›„ ë°”ë¡œ ì‹¤í–‰
# ì²« ë²ˆì§¸ ë§¤ì¹­ëœ íƒ€ì´í‹€ì„ ê¸°ì¤€ìœ¼ë¡œ process ê²€ìƒ‰
# ìµœì´ˆ 1íšŒë§Œ í ì†Œë¹„ ì“°ë ˆë“œ ì‹œìž‘
# ì¶œë ¥ìš© ì •ë ¬: ìœ ì‚¬í•œ ê²ƒ ë¨¼ì €
# í ëª¨ë“œ: ìˆœì„œëŒ€ë¡œ ìž¬ìƒ
# íŒŒì¼ ë³µì‚¬
# í•´ë‹¹ íƒ€ì´í‹€ì„ ê°€ì§„ ìœˆë„ìš°ë“¤ì˜ PID ì§ì ‘ ìˆ˜ì§‘
# í˜„ìž¬ exec  ì¤‘ì¸ ëª¨ë“  ìŠ¤ë ˆë“œ ê°€ì ¸ì˜¤ê¸°
'â€“': '-',  # EN DASH
'â€”': '-',  # EM DASH
'â€˜': "'", 'â€™': "'",
'â€œ': '"', 'â€': '"',
'â€¦': '...', 'â€¢': '*',
)
).start()
:param sort: Trueì¼ ê²½ìš° ì•ŒíŒŒë²³ ìˆœ ì •ë ¬
:param timeout: ì¢…ë£Œ ëŒ€ê¸° ì‹œê°„ (ì´ˆ)
:param unique: Trueì¼ ê²½ìš° ì¤‘ë³µ remove
:param window_title_seg: ìœˆë„ìš° ì œëª© ì¼ë¶€ ë¬¸ìžì—´
:return: True (ëª¨ë‘ ì¢…ë£Œë¨), False (í•˜ë‚˜ë¼ë„ ì¢…ë£Œ ì‹¤íŒ¨)
:return: í”„ë¡œì„¸ìŠ¤ ì´ë¦„ ë¦¬ìŠ¤íŠ¸
@pk_measure_seconds
Args:
Copy files from src_dir to dst_dir excluding any files or directories
DEST_DIR = rf"{downloads_path}\auto_utility"
EXCLUDE_NAMES = {
None_count = Nones.count(None)
Nones = [img_name, pid]
PLAYING_SOUNDS.clear()
Print and return current alive threads.
Returns:
SCRIPT_NAME = Path(__file__).name
SOURCE_DIR = rf"{downloads_path}\pk_system"
['taskkill', '/PID', str(pid), '/T', '/F'],
]
_, pid = win32process.GetWindowThreadProcessId(hwnd)
_, status_out = run_command("git status", capture_output=True)
all_killed = False
all_killed = True
and target in " ".join(proc.info.get('cmdline', [])).lower()
async def pk_kill_process_as_async(f):
await asyncio.gather(*tasks)  # ëª¨ë“  í”„ë¡œì„¸ìŠ¤ë¥¼ ë¹„ë™ê¸°ì ìœ¼ë¡œ ì¢…ë£Œ
batch_calling_program = 'start "" call'
batch_file = get_pnx_os_style(rf'{batch_file_base}/{batch_filename}')
batch_file_base = D_PROJECT
batch_filename = rf"pk_push_project_to_github.bat"
best_match_hwnd, best_match_title, _ = matches[0]
best_match_title = matches[0][1]
break
c = wmi.WMI()
caption_match = "cmd.exe" in (proc.Caption or "").lower()
chcp_65001()
choice = input("ì‹¤í–‰í•  ë²ˆí˜¸ë¥¼ ìž…ë ¥í•˜ì„¸ìš” (Enterë¡œ ì·¨ì†Œ): ").strip()
closed_hwnds = []
closed_hwnds.append((hwnd, title))
cmd = "git add ."
cmd = "git push"
cmd = "wsl --shutdown"
cmd = f'git commit -m "{commit_message}"'
cmd = f'git config --global user.email "{user_email}"'
cmd = f'git config --global user.name "{user_name}"'
cmd = f'python3 {file_to_excute}'
cmd = f'start "" cmd.exe /k "title {file_title}&& python {file_to_excute}"'
cmd = f'tasklist /FI "WINDOWTITLE eq {window_title}" /FO CSV'
cmd_to_os(cmd=cmd)
cmd_to_os(cmd=cmd, mode="a")
cmd_to_os(cmd=cmd, mode='a', mode_with_window=1)
cmd_to_os(cmd=f'{batch_calling_program} "{batch_file}"')
cmd_to_os(cmd=f'{python_calling_program} "{python_file}"')
cmd_to_os(cmd=rf'"{f_cmd}"', encoding='utf-8')
cmd_to_os(cmd=rf'"{f_cmd}"', encoding=Encoding.CP949)
cmd_to_os(f'taskkill /f /im "{img_name}"')
cmd_to_os(f'taskkill /f /pid {pid}')
cmd_to_os(f'wmic process where name="{img_name}" delete ')
cmd_to_os(f'wmic process where name="{process_img_n}" delete ')
cmdline = " ".join(proc.info['cmdline']).lower()
cmdline = ' '.join(proc.info['cmdline']) if proc.info['cmdline'] else ''
cmdline = process.info.get('cmdline', [])
code, log_output = run_command('git log -n 20 --pretty=format:%s', capture_output=True)
code, output = run_command(cmd, capture_output=True)
commit_message = None
commit_message = commit_message.strip()
commit_message = f"feat: auto pushed (made savepoint) by {SCRIPT_NAME} at {get_time_as_("%Y-%m-%d %H:%M")}"
commit_message = f"feat: auto pushed (made savepoint) by {SCRIPT_NAME}"
commit_message = get_value_completed(key_hint='commit_message=', values=options)
commit_message = input("commit_message=").strip()
commit_message = value
commit_number = get_next_commit_number()
content = file_path.read_text().strip()
continue
continue  # ê¶Œí•œ ì˜¤ë¥˜ë‚˜ ì¡´ìž¬í•˜ì§€ ì•ŠëŠ” í”„ë¡œì„¸ìŠ¤ëŠ” ë¬´ì‹œ
copied_count += 1
copied_count = 0
copy_except_blacklist(SOURCE_DIR, DEST_DIR, EXCLUDE_NAMES)
cpu = proc.cpu_percent()
cpu = proc.cpu_percent(interval=duration)
current_threads = threading.enumerate()
daemon=True
def copy_and_push_auto_utility():
def copy_except_blacklist(src_dir, dst_dir, exclude_names):
def debug_as_ipdb_console(ipdb):
def debug_call_depth(func_n):
def debug_call_stack():
def debug_current_threads(verbose: bool = True) -> list:
def debug_this_code_operated(ipdb: ModuleType):
def ensure_cmd_exe_all_closed_in_loop():
def ensure_cmd_exe_deduplicated():
def ensure_cmd_exe_deduplicated_all():
def ensure_cmd_exe_deduplicated_all_in_loop():
def ensure_git_project_pushed(with_commit_massage=True):
def enum_handler(hwnd, _):
def enum_handler(hwnd, matched_hwnds):
def fail_and_exit(start_time):
def fallback_choice(pk_file_list: list[str], last_selected: str | None):
def get_fzf_command():
def get_history_file_path(file_id: str) -> Path:
def get_last_history(history_file):
def get_next_commit_number():
def get_nx(path: str) -> str:
def get_pids_by_title_seg(windows_title_seg: str) -> list[int]:
def get_process_name_list(unique: bool = True, sort: bool = True) -> list:
def get_refactor_py_file_list():
def get_text_from_history_file(file_id: str) -> str | None:
def get_value_via_fzf_or_history_routine(key_name, file_id, editable, init_options=[]):
def get_values_sanitize_for_cp949(text):
def get_window_matches(window_title_seg: str):
def get_window_title(window_title_seg: str) -> str | None:
def is_a2z_office():
def is_process_killed(window_title_seg: str, timeout: float = 1.0) -> bool:
def kill_cmd_exe():
def kill_pid(pid):
def kill_pid_psutil(pid):
def kill_powershell_exe(debug_mode=True):
def kill_process(img_name=None, pid=None):
def kill_process_via_wmic(process_img_n=None, debug_mode=True):
def kill_thread(thread_name):
def kill_us_keyboard():
def kill_wsl_exe():
def listen_enter():
def main_loop():
def monitor_process_state(proc, duration=1.0):
def monitor_process_state(proc, max_sec=2.5, interval=0.5):
def pk_ensure_process_deduplicated(window_title_seg: str, exact=True):
def pk_ensure_process_killed(window_title: str):
def pk_kill_process_by_window_title_seg(window_title_seg: str):
def pk_kill_process_v1(cmd_exe_title):
def pk_kill_process_v10(window_title_seg: str):
def pk_kill_process_v11(window_title_seg: str):
def pk_kill_process_v12(window_title_seg: str):
def pk_kill_process_v13(window_title_seg: str):
def pk_kill_process_v14(window_title_seg: str):
def pk_kill_process_v15(window_title_seg: str):
def pk_kill_process_v16(window_title: str, exact: bool = True):
def pk_kill_process_v16_1(window_title: str, exact: bool = True):
def pk_kill_process_v17(window_title_seg: str):
def pk_kill_process_v17_fast(window_title_seg: str):
def pk_kill_process_v2(cmd_exe_title: str):
def pk_kill_process_v3(cmd_exe_title: str):
def pk_kill_process_v5(cmd_exe_title: str):
def pk_kill_process_v6(cmd_exe_title: str):
def pk_kill_process_v8(window_title_seg: str):
def pk_kill_process_v9(window_title_seg: str):
def pk_run_py_system_process_by_pnx(file_to_excute, file_title):
def pk_speak_v3(str_working, segment_delay=0.90, queue_mode=False):
def pk_test_function_name():
def pk_test_get_value_with_tab_v80():
def pk_test_get_value_with_tab_v90():
def pk_test_guide_not_prepared_yet():
def pk_test_path_normalized():
def pk_test_pk_python_program_structure():
def pk_test_stop_with_silent_debugger():
def pk_test_window_title_debugger():
def print_status(step_num: int, cmd: str, code: int, output: str) -> str:
def process_queue():
def run_command(cmd: str, capture_output=False):
def save_to_history(contents_to_save: str, history_file):
def set_text_from_history_file(file_id: str, text: str):
def stop_all_sounds():
def test_example_call_batchfile_as_new_window():
def test_example_call_pythonfile_as_new_window():
def try_kill_pid(pid):
depth = debug_call_depth(func_n)
depth = len(inspect.stack(0))
dirs[:] = [d for d in dirs if d not in exclude_names]
downloads_path = os.path.join(os.environ["USERPROFILE"], "Downloads")
dst = rf"{DEST_DIR}\.gitignore"
dst_dir (str): Destination directory.
dst_path = os.path.join(dst_dir, rel_path)
duration = time.time() - start_time
editable = False
editable = True
editable = True  # pk_option
elapsed = time.time() - start
elif "everything up-to-date" in output.lower():
elif "nothing to commit" in output.lower():
elif elapsed > 2.5:
elif is_os_wsl_linux():
else:
ensure_cmd_exe_deduplicated_all()
ensure_console_debuggable(ipdb)
ensure_do_exception_routine(traceback=traceback, exception=e)
ensure_do_exception_routine(traceback=traceback, exception=exception)
ensure_do_finally_routine(D_PROJECT=D_PROJECT, __file__=__file__, STAMP_TRY_GUIDE=STAMP_TRY_GUIDE)
ensure_pk_system_exit_silent()  # pk_option
except (ValueError, IndexError):
except (psutil.AccessDenied, psutil.ZombieProcess, psutil.NoSuchProcess):
except (psutil.NoSuchProcess, psutil.AccessDenied):
except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
except Exception as e:
except Exception as exception:
except Exception:
except FileNotFoundError:
except ImportError as e:
except psutil.NoSuchProcess:
except psutil.TimeoutExpired:
except subprocess.CalledProcessError:
except subprocess.TimeoutExpired:
except:
exclude_names (set): Set of names (files or folders) to exclude.
exe = proc.name().lower()
executor.map(kill_pid, matched_pids)
executor.map(kill_pid_psutil, matched_pids)
executor.map(try_kill_pid, matched_pids)
existing_shm = shared_memory.SharedMemory(name=shm_name)
existing_shm.close()
f = get_pnx_os_style(f)
f = str(Path(f).resolve())
f"feat: auto pushed (made savepoint) by {SCRIPT_NAME} at {get_time_as_("%Y-%m-%d %H:%M")}",
f_cmd = get_pnx_os_style(pnx=f_cmd)
f_cmd = rf"{D_PKG_WINDOWS}/pk_kill_us_keyboard.cmd"
f_historical = get_history_file(file_id=file_id)
f_nx = get_nx(f)
f_obj.write(contents_to_save.strip())
f_working = value
fail_and_exit(start_time)
failed_pids = []
failed_pids.append(pid)
file_id = get_file_id(key_name, func_n)
file_path = get_history_file_path(file_id)
file_path.write_text("")  # create an empty file
file_path.write_text(text.strip())
file_title = file_title.strip()
finally:
flag = existing_shm.buf
flag[0] = 0  # flagë¥¼ ë‹¤ì‹œ Falseë¡œ ì´ˆê¸°í™”
flag[0] = 1  # flagë¥¼ Trueë¡œ ë³€ê²½
fname = os.path.basename(fpath)
for _ in range(sleep_seconds):
for _ in range(steps):
for file in files:
for frame in inspect.stack()[1:5]:
for hwnd in to_close:
for hwnd, title in matched_hwnds:
for hwnd, title, is_similar in matches:
for idx, fpath in enumerate(pk_file_list):
for line in log_output.splitlines():
for name in ["fzf", "fzf.exe"]:
for old, new in replacements.items():
for pid in matched_pids:
for pid in pids:
for player in PLAYING_SOUNDS:
for proc in c.Win32_Process():
for proc in c.query("SELECT ProcessId, CommandLine, Caption FROM Win32_Process"):
for proc in psutil.process_iter(['name']):
for proc in psutil.process_iter(['pid', 'name', 'cmdline'])
for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
for process in psutil.process_iter(['pid', 'name', 'cmdline']):
for root, dirs, files in os.walk(src_dir):
for row in reader:
for seg in working_list:
for t in thread_list:
for thread in current_threads:
for title in values:
for window_title in grouped:
from collections import defaultdict
from concurrent.futures import ThreadPoolExecutor
from io import StringIO
from multiprocessing import shared_memory, Lock
from pathlib import Path
from pkg_py.functions_split.chcp_65001 import chcp_65001
from pkg_py.functions_split.cmd_to_os import cmd_to_os
from pkg_py.functions_split.colorama_init_once import pk_colorama_init_once
from pkg_py.functions_split.ensure_console_debuggable import ensure_console_debuggable
from pkg_py.functions_split.ensure_do_exception_routine import ensure_do_exception_routine
from pkg_py.functions_split.ensure_do_finally_routine import ensure_do_finally_routine
from pkg_py.functions_split.ensure_os_env_sys_variables_applied import ensure_os_env_sys_variables_applied
from pkg_py.functions_split.ensure_pk_system_exit_silent import ensure_pk_system_exit_silent
from pkg_py.functions_split.get_f_historical import get_history_file
from pkg_py.functions_split.get_file_id import get_file_id
from pkg_py.functions_split.get_list_calculated import get_list_calculated
from pkg_py.functions_split.get_list_sorted import get_list_sorted
from pkg_py.functions_split.get_nx import get_nx
from pkg_py.functions_split.get_os_n import get_os_n
from pkg_py.functions_split.get_pids import get_pids
from pkg_py.functions_split.get_pnx_os_style import get_pnx_os_style
from pkg_py.functions_split.get_time_as_ import get_time_as_
from pkg_py.functions_split.get_value_completed import get_value_completed
from pkg_py.functions_split.get_values_from_historical_file import get_values_from_history_file
from pkg_py.functions_split.get_window_title import get_window_title
from pkg_py.functions_split.get_window_title_list import get_window_title_list
from pkg_py.functions_split.is_containing_special_characters_with_thread import is_containing_special_characters_with_thread
from pkg_py.functions_split.is_os_windows import is_os_windows
from pkg_py.functions_split.is_os_wsl_linux import is_os_wsl_linux
from pkg_py.functions_split.kill_process_via_taskkill import kill_process_via_taskkill
from pkg_py.functions_split.measure_seconds import pk_measure_seconds
from pkg_py.functions_split.press import pk_press
from pkg_py.functions_split.print import pk_print
from pkg_py.functions_split.print_iterable_as_vertical import print_iterable_as_vertical
from pkg_py.functions_split.remove_special_characters import remove_special_characters
from pkg_py.functions_split.set_values_to_historical_file import set_values_to_historical_file
from pkg_py.functions_split.sleep import pk_sleep
from pkg_py.functions_split.speak import pk_speak
from pkg_py.functions_split.write_like_person import write_like_person
from pkg_py.pk_interface_graphic_user import get_windows_opened
from pkg_py.system_object.color_map import PK_ANSI_COLOR_MAP
from pkg_py.system_object.directories import D_PKG_WINDOWS
from pkg_py.system_object.directories_reuseable import D_PROJECT
from pkg_py.system_object.directories_reuseable import D_PROJECT, D_HOME
from pkg_py.system_object.encodings import Encoding
from pkg_py.system_object.etc import PK_UNDERLINE
from pkg_py.system_object.etc import PLAYING_SOUNDS
from pkg_py.system_object.files import F_PK_WORKSPACE_PY
from pkg_py.system_object.local_test_activate import LTA
from pkg_py.system_object.map_massages import PkMessages2025
from pkg_py.system_object.stamps import STAMP_TRY_GUIDE
from pkg_py.workspace.pk_workspace import debug_this_code_operated
from pkg_py.workspace.pk_workspace2 import get_value_via_fzf_or_history
from types import ModuleType
func_n = inspect.currentframe().f_code.co_name
global step_counter
grouped = defaultdict(list)
grouped[title].append(title)
historical_values = get_values_from_history_file(f_historical=f_historical)
history_dir = Path.home() / ".git_config_history"
history_dir.mkdir(parents=True, exist_ok=True)
hwnds = []
hwnds.append(hwnd)
if "cmd.exe" in (proc.Caption or "").lower() and get_nx(window_title).lower() in (proc.CommandLine or "").lower():
if "user" in D_HOME:
if 'cmd.exe' in (proc.info['name'] or '').lower() and cmd_exe_title.lower() in cmdline.lower():
if 'cmd.exe' in (proc.info['name'] or '').lower() and window_title.lower() in ' '.join(proc.info['cmdline'] or []).lower():
if (exact and title == window_title) or (not exact and window_title in title):
if LTA:
if None_count == 0:
if None_count == 1:
if None_count == 2:
if __name__ == "__main__":
if any(protocol in output for protocol in ["To https://", "To http://", "To git@"]):
if capture_output:
if cmdline and any(f_nx in cmd for cmd in cmdline):
if code != 0:
if code == 0:
if commit_message == "":
if elapsed > 2.0:
if elapsed > 2.5:
if elapsed > 5.0:
if exact:
if exe == "cmd.exe":
if failed_pids:
if file in exclude_names:
if flag[0]:  # flagê°€ Trueë©´ ë¦¬ì…‹ í›„ ë£¨í”„ ìž¬ì‹œìž‘
if get_os_n() == 'windows':
if img_name is not None:
if is_containing_special_characters_with_thread(text=str_working):
if is_os_windows():
if is_similar:
if len(user_email.strip()) == 0:
if len(user_name.strip()) == 0:
if limit_of_call_depth >= depth:
if match:
if matched_pids:
if matches:
if not choice:
if not closed_hwnds:
if not file_path.exists():
if not hasattr(pk_speak_v3, "_queue"):
if not hwnds:
if not matched_hwnds:
if not matched_pids:
if not matches:
if not os.path.exists(dst_dir):
if not pids:
if not proc.is_running():
if not str_working:
if not title:
if not window_title:
if os.path.exists(dst):
if os.path.exists(history_file):
if pid is not None:
if pid:
if pids is not None:
if proc.info['name'].lower() == "cmd.exe":
if proc.info['name'].lower() == 'cmd.exe'
if proc.info['name']:
if proc.is_running():
if process.info['cmdline'] and any(cmd_exe_title in cmd for cmd in process.info['cmdline']):
if process_img_n is not None:
if queue_mode and not pk_speak_v3._thread_started:
if queue_mode:
if sort:
if status == "FAILED":
if target in cmdline:
if target_thread:
if tasks:
if thread.name == thread_name:
if title.lower() == window_title.lower():
if title:
if title_match and caption_match:
if unique:
if verbose:
if win32gui.IsWindowVisible(hwnd):
if window_title.lower() in title.lower():
if window_title_seg.lower() in title.lower():
if with_commit_massage == False:
img_name = img_name.replace("\"", "")
img_name = img_name.replace("\'", "")
import asyncio
import csv
import glob
import inspect
import ipdb
import logging
import os
import psutil
import queue
import re
import shutil
import subprocess
import sys
import threading
import time
import traceback
import win32con
import win32gui
import win32process
import wmi
init_options = [F_PK_WORKSPACE_PY]
init_options = get_list_calculated(origin_list=[selected], plus_list=init_options)  # ì„ íƒê°’ì„ ë§¨ ì•žìœ¼ë¡œ ì •ë ¬
init_options = get_list_calculated(origin_list=init_options, dedup=True)
init_options = get_list_calculated(origin_list=init_options, plus_list=historical_values)
input()  # Enter ìž…ë ¥ ëŒ€ê¸°
ipdb.set_trace()
key_name = "commit_message"
key_name = 'commit_message'
key_name = 'f_working'
key_name = 'window_opened'
kill_process(pid=pid)
kill_process_via_taskkill(pid=pid)
kill_process_via_wmic(pid=pid)
label, color = "FAILED", PK_ANSI_COLOR_MAP['RED']
label, color = "SKIPPED", PK_ANSI_COLOR_MAP['YELLOW']
label, color = "SUCCESS", PK_ANSI_COLOR_MAP['GREEN']
limit_of_call_depth = 10
list: List of thread names.
lock = Lock()
logging.debug(f"[ENUM] hwnd={hwnd}, title='{title}', target='{window_title}'")
logging.error(f"[ERROR] No valid PID found for window title: '{window_title}'")
logging.error(f"[EnumWindows ERROR] {e}")
logging.error(f"[FAILED PIDs] {sorted(failed_pids)}")
logging.error(f"[FAILED] PID={pid} error: {e}")
logging.error(f"[IMPORT ERROR] {e}. Please install pywin32.")
logging.info(f"[CLOSE:EXACT] '{title}' (hwnd={hwnd})")
logging.info(f"[CLOSE:PARTIAL] '{title}' (hwnd={hwnd})")
logging.info(f"[HWND->PID] title='{title}' â†’ pid={pid}")
logging.info(f"[INFO] Closed {len(closed_hwnds)} window(s) for '{window_title}'")
logging.info(f"[INFO] Found {len(matched_hwnds)} matched window(s) for '{window_title}'")
logging.info(f"[KILLED] PID={pid} ('{window_title}') exe='{exe}'")
logging.info(f"[MATCHED:EXACT] '{title}'")
logging.info(f"[MATCHED:PARTIAL] '{title}'")
logging.warning(f"[SKIP] No window matched for: '{window_title}' (exact={exact})")
logging.warning(f"[SKIP] Not killing cmd.exe (PID={pid})")
logging.warning(f"[WARN] Failed to get PID from hwnd={hwnd}: {e}")
main_loop()
mark = " <- ìµœê·¼ ì‹¤í–‰" if fpath == last_selected else ""
match = re.match(r"\[(\d+)\]", line)
matched_hwnds = []
matched_hwnds.append((hwnd, title))
matched_pids = set()
matched_pids = {
matched_pids.add(pid)
matched_pids.add(proc.ProcessId)
matched_pids.add(proc.info['pid'])
matches = []
matches = get_window_matches(window_title_seg)
matches = get_window_title(windows_title_seg)
matches.append((hwnd, title))
matches.append((hwnd, title, similarity))
matches.sort(key=lambda x: x[2], reverse=True)
mem = proc.memory_info().rss / (1024 * 1024)
monitor_process_state(proc)
monitor_process_state(proc)  # ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ì‹œìž‘
monitor_process_state(proc, duration=0.5)
name = process.info['name']
name="thread_speak_queue",
names = []
names = list(set(names))
names.append(proc.info['name'])
names.sort()
numbers = []
numbers.append(int(match.group(1)))
options = [
os.chdir(batch_file_base)
os.chdir(path=DEST_DIR)
os.chdir(python_file_base)
os.makedirs(dst_dir)
os.makedirs(os.path.dirname(dst_path), exist_ok=True)
os.remove(dst)  # ë®ì–´ì“°ê¸°
os.system(command=rf"call {DEST_DIR}\pk_push_project_to_github_hybrid.bat")
os.system(f"title {os.path.basename(__file__)}")  # TBD : ë°ì½”ë ˆì´í„°ë¡œ ì „í™˜
output = subprocess.check_output(cmd, shell=True, encoding='cp949', errors='ignore')
pass
pass  # ìµœì¢… íƒ€ìž„ì•„ì›ƒ 2ì´ˆ ê²½ê³¼ í›„ í¬ê¸°
pattern = os.path.join(refactor_dir, "*.py")
pid = process.info['pid']
pid = row.get("PID")
pids = get_pids("cmd.exe")
pids = get_pids("powershell.exe")
pids = get_pids("wsl.exe")
pids = get_pids_by_title_seg(window_title_seg)
pk_colorama_init_once()
pk_ensure_process_deduplicated(window_title_seg=window_opened)
pk_ensure_process_deduplicated(window_title_seg=window_title, exact=True)
pk_ensure_process_killed(window_title=window_opened)
pk_kill_process_v17(window_title)
pk_press("enter")
pk_print("Enter detected! Restarting loop...", print_color="white")
pk_print("Enter detected! flag ì—…ë°ì´íŠ¸ë¨.", print_color="blue")
pk_print("listen_enter: ê³µìœ  ë©”ëª¨ë¦¬ê°€ ì¡´ìž¬í•˜ì§€ ì•ŠìŒ. ì¢…ë£Œ.", print_color='red')
pk_print("main_loop: ê³µìœ  ë©”ëª¨ë¦¬ê°€ ì¡´ìž¬í•˜ì§€ ì•ŠìŒ. ì¢…ë£Œ.", print_color='red')
pk_print(f"PK KILL '{best_match_title}' not found (No PIDs)", print_color="red")
pk_print(f"PK KILL '{best_match_title}' not found", print_color="red")
pk_print(f"PK KILL '{window_title}' not found", print_color="red")
pk_print(f"PK KILL ERROR PID={pid} : {e}", print_color="red")
pk_print(f"PK KILL PID={pid} TIMEOUT_ELAPSED={elapsed:.2f}s", print_color="yellow")
pk_print(f"PK KILL PID={pid} window_title=...", print_color="green")
pk_print(f"PK KILL PID={pid} window_title={window_title}", print_color="green")
pk_print(f"[CLOSE] HWND={hwnd} closed for window_title='{win32gui.GetWindowText(hwnd)}'", print_color="green")
pk_print(f"[DEBUG] window_title={window_title} {'%%%FOO%%%' if LTA else ''}")
pk_print(f"[ERROR] {e}", print_color="red")
pk_print(f"[ERROR] ì „ì²´ ì¢…ë£Œ í™•ì¸ ì‹¤íŒ¨: {e}", print_color="red")
pk_print(f"[INFO] Found {len(matches)} window(s). Similarity check:", print_color="cyan")
pk_print(f"[NO MATCH] '{cmd_exe_title}' í”„ë¡œì„¸ìŠ¤ë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.", print_color="red")
pk_print(f"[NO MATCH] '{cmd_exe_title}'ì™€ ì¼ì¹˜í•˜ëŠ” í”„ë¡œì„¸ìŠ¤ë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.", print_color="red")
pk_print(f"[NO MATCH] '{window_title}'ì™€ ì¼ì¹˜í•˜ëŠ” í”„ë¡œì„¸ìŠ¤ë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.", print_color="red")
pk_print(f"[PK KILL] PID={pid} cmd_exe_title={cmd_exe_title}", print_color="green")
pk_print(f"[PK KILL] PID={pid} window_title={window_title}", print_color="green")
pk_print(f"[PROCESS TERMINATED] PID={pid}, Name={process.info['name']}", print_color="green")
pk_print(f"[PROCESS TERMINATED] ì‹œê°„ ì´ˆê³¼ ", print_color='red')
pk_print(f"[SKIP] No matching process found for '{window_title_seg}'", print_color="yellow")
pk_print(f"[SKIP] No matching windows for '{window_title}'", print_color="red")
pk_print(f"[SKIP] No window found for seg='{window_title_seg}'", print_color="yellow")
pk_print(f"[SURVIVED] HWND={survivor_hwnd} kept alive â†’ '{win32gui.GetWindowText(survivor_hwnd)}'", print_color="yellow")
pk_print(f"[TASKKILL ERROR] PID={pid}, {e}", print_color="red")
pk_print(f"[TIMEOUT] PID={pid} taskkill took too long", print_color="yellow")
pk_print(f"[TIMEOUT] taskkill for PID={pid} timed out", print_color="yellow")
pk_print(f"[WARN] psutil error: {e}", print_color="yellow")
pk_print(f"[ì²˜ë¦¬ ì¤‘] ì°½ ì œëª©='{window_title}' ì¤‘ë³µ ì œê±°", print_color="cyan")
pk_print(f"wait for enter  {'%%%FOO%%%' if LTA else ''}", print_color='white')
pk_print(f"window_title={window_title} {'%%%FOO%%%' if LTA else ''}")
pk_print(f"{PK_ANSI_COLOR_MAP['GREEN']}here! here! here! here! here! here! here! here! here! here! here! here! {PK_ANSI_COLOR_MAP['RESET']}")
pk_print(f"{sim_mark} [{hwnd}] {title}", print_color="cyan")
pk_print(f"â€¼ï¸ FORCED TIMEOUT: PID={pid} took {elapsed:.2f}s", print_color="red")
pk_print(f"âš ï¸ PID={pid} ì—¬ì „ížˆ ì‹¤í–‰ ì¤‘", print_color="yellow")
pk_print(f"âš ï¸ PK KILL PID={pid} TIMEOUT_ELAPSED={elapsed:.2f}s", print_color="red")
pk_print(f"âœ… PID={pid} ì¢…ë£Œ í™•ì¸ë¨", print_color="green")
pk_print(f"âœ… PK KILL PID={pid} title_match={best_match_title}", print_color="green")
pk_print(f"âœ… PK KILL PID={pid} window_title={best_match_title}", print_color="green")
pk_print(f"âœ… PK KILL PID={pid} window_title={window_title}", print_color="green")
pk_print(f"âŒ PK KILL ERROR PID={pid} : {e}", print_color="red")
pk_print(f"âŒ ì˜ˆì™¸ ë°œìƒ PID={pid}, error={e}", print_color="red")
pk_print(f"â— FAILED PIDs: {sorted(failed_pids)}", print_color="red")
pk_print(f"ðŸ‘ï¸ End monitoring PID={proc.pid}", print_color="blue")
pk_print(f"ðŸ‘ï¸ Monitor PID={proc.pid}", print_color="blue")
pk_print(f"ðŸ‘ï¸ Start monitoring PID={proc.pid}", print_color="blue")
pk_print(f"ðŸ” PID={proc.pid} CPU={cpu:.1f}% MEM={mem:.1f}MB TH={th}", print_color="blue")
pk_print(f"ðŸ” PID={proc.pid} CPU={cpu:.1f}% MEM={mem:.1f}MB TH={th}", print_color="yellow")
pk_print(f"ðŸ›‘ PID={pid} ì¢…ë£Œ ì‹¤íŒ¨ (TIMEOUT)", print_color="red")
pk_print(f"ðŸªŸ Using best match title: {best_match_title} {'%%%FOO%%%' if LTA else ''}", print_color="cyan")
pk_print(f'''[{PkMessages2025.DATA}] contents_to_save={contents_to_save} {'%%%FOO%%%' if LTA else ''}''')
pk_print(f'''[{PkMessages2025.DATA}] history_file={history_file} {'%%%FOO%%%' if LTA else ''}''')
pk_print(f'''[{PkMessages2025.DATA}] options={init_options} {'%%%FOO%%%' if LTA else ''}''')
pk_print(f'''[{PkMessages2025.DATA}] value={value} {'%%%FOO%%%' if LTA else ''}''')
pk_print(f'''cmd={cmd} {'%%%FOO%%%' if LTA else ''}''')
pk_print(f'''cmd_exe_title={cmd_exe_title}  {'%%%FOO%%%' if LTA else ''}''', print_color="blue")
pk_print(f'''commit_message={commit_message} {'%%%FOO%%%' if LTA else ''}''')
pk_print(f'''f_working={f_working} {'%%%FOO%%%' if LTA else ''}''')
pk_print(f'''window_opened={window_opened} {'%%%FOO%%%' if LTA else ''}''')
pk_print(f'''window_title={window_title} {'%%%FOO%%%' if LTA else ''}''')
pk_print(f'''{PkMessages2025.NOT_PREPARED_YET}{'%%%FOO%%%' if LTA else ''}''', print_color='green', mode_verbose=0)
pk_print(rf"{func_n}() ë™ìž‘ ì¡°ê±´ ë¶ˆì¶©ì¡±")
pk_print(rf"{func_n}() ë™ìž‘ ì¡°ê±´ ì¶©ì¡±")
pk_print(rf"ê¸°ì¡´ ê³µìœ  ë©”ëª¨ë¦¬ ë°œê²¬, ì´ˆê¸°í™” ìƒëžµ shm_name={shm_name}", print_color="green")
pk_print(rf"ìƒˆë¡œìš´ ê³µìœ  ë©”ëª¨ë¦¬ ìƒì„± shm_name={shm_name}", print_color="green")
pk_print(str_working=rf''' ì´ {func_n}()ì˜ ì¸ìžëŠ” ìµœëŒ€ 1ê°œ ê¹Œì§€ ë°›ì„ ìˆ˜ ìžˆìŠµë‹ˆë‹¤.  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
pk_print(str_working=rf''' ì´ {func_n}()ì˜ ì¸ìžëŠ” ìµœì†Œ 1ê°œì˜ ì¸ìžê°€ ìš”êµ¬ë©ë‹ˆë‹¤.  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
pk_print(str_working=rf'''{'%%%FOO%%%' if LTA else ''}''', print_color='red')
pk_print(str_working=rf'''{PK_UNDERLINE}{func_n}()  {'%%%FOO%%%' if LTA else ''}''')
pk_sleep(milliseconds=200)
pk_sleep(milliseconds=200)  # ë„ˆë¬´ ë¹ ë¥´ê²Œ ë°˜ë³µë˜ì§€ ì•Šë„ë¡ ì•½ê°„ ëŒ€ê¸°
pk_sleep(seconds=1)
pk_speak(seg, after_delay=delay)
pk_speak(seg, after_delay=segment_delay)
pk_speak_v3._queue = queue.Queue()
pk_speak_v3._queue.put((seg, segment_delay))
pk_speak_v3._queue.task_done()
pk_speak_v3._thread_started = False
pk_speak_v3._thread_started = True
player.delete()
player.pause()
print("[CALL STACK]")
print("â€» fzf ë¯¸ì„¤ì¹˜ â†’ fallback ì„ íƒ ëª¨ë“œ ì‚¬ìš©")
print(PK_UNDERLINE)
print(f"  - name={t.name}, daemon={t.daemon}, alive={t.is_alive()}, ident={t.ident}")
print(f"  - {frame.function} @ {frame.filename}:{frame.lineno}")
print(f"LOCAL LEPO : {PK_ANSI_COLOR_MAP['GREEN']}{os.getcwd()}{PK_ANSI_COLOR_MAP['RESET']}")
print(f"STARTED AT : {PK_ANSI_COLOR_MAP['GREEN']}{time.strftime('%Y-%m-%d %H:%M:%S')}{PK_ANSI_COLOR_MAP['RESET']}")
print(f"[ {color}{label}{PK_ANSI_COLOR_MAP['RESET']} ] [{step_num}] {cmd}")
print(f"[COPIED] {rel_path}")
print(f"[DEBUG] CALL DEPTH ({func_n}): {depth}")
print(f"[ERROR] Source file not found: {src}")
print(f"[ERROR] Too deep: depth={depth}")
print(f"[ERROR] Unexpected error: {e}")
print(f"[INFO] Active thread count: {len(thread_list)}")
print(f"[OK] Overwritten:\n{src}\nâ†’ {dst}")
print(f"[{PkMessages2025.DONE}] {copied_count} file(s) copied to '{dst_dir}'.")
print(f"[{idx}] {fname}{mark}")
print(f"[ì‹¤í–‰ ì¤‘ - Linux/Unix] {cmd}")
print(f"[ì‹¤í–‰ ì¤‘ - WSL] {cmd}")
print(f"[ì‹¤í–‰ ì¤‘ - Windows] {cmd}")
print(f"\n{PK_ANSI_COLOR_MAP['RED']}[!] Aborting further steps. Current git status:{PK_ANSI_COLOR_MAP['RESET']}")
print(f"{PK_ANSI_COLOR_MAP['GREEN']}ALL PROCESS COMPLETED SUCCESSFULLY. TOTAL EXECUTION TIME: {duration:.2f} SECONDS {PK_ANSI_COLOR_MAP['RESET']}")
print(f"{PK_ANSI_COLOR_MAP['RED']}process failed at {time.strftime('%Y-%m-%d %H:%M:%S')} (elapsed {duration:.2f} sec){PK_ANSI_COLOR_MAP['RESET']}")
print(f"{thread_name} ìŠ¤ë ˆë“œê°€ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.")
print(f"{thread_name} ìŠ¤ë ˆë“œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
print(output.strip())
print(status_out.strip())
print_iterable_as_vertical(item_iterable=sorted(grouped), item_iterable_n="ì¤‘ë³µ í™•ì¸ ëŒ€ìƒ ì°½ ì œëª©ë“¤")
print_iterable_as_vertical(item_iterable=values, item_iterable_n="values")
print_iterable_as_vertical(item_iterable=window_opened_list, item_iterable_n="window_opened_list")
print_iterable_as_vertical(item_iterable=window_title_list, item_iterable_n="window_title_list")
proc = psutil.Process(pid)
proc.info['pid']
proc.kill()
proc.terminate()
proc.terminate()  # í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ ìš”ì²­
proc.wait(timeout=1)
proc.wait(timeout=5)  # ì¢…ë£Œ ì™„ë£Œë¥¼ ëŒ€ê¸°, ìµœëŒ€ 5ì´ˆ ëŒ€ê¸°
proc.wait(timeout=timeout)
process_img_n = process_img_n.replace("\"", "")
process_img_n = process_img_n.replace("\'", "")
process_name = "wsl.exe"
python_calling_program = 'start "" python'
python_file = get_pnx_os_style(rf'{python_file_base}/{python_filename}')
python_file_base = D_PROJECT
python_filename = rf"pk_push_project_to_github.py"
reader = csv.DictReader(StringIO(output))
refactor_dir = os.path.join(os.path.dirname(__file__), "../refactor")
rel_path = os.path.relpath(src_path, src_dir)
replacements = {
result = subprocess.run(cmd, shell=True)
result = subprocess.run(cmd, shell=True, text=True, capture_output=True)
return
return  # ðŸ’¥ ë³‘ëª© ë°©ì§€ìš© ì¡°ê¸° ì¢…ë£Œ
return 1
return 1, str(e)
return False
return None
return True
return True  # ì´ë¯¸ ì¢…ë£Œëœ ê²ƒìœ¼ë¡œ ê°„ì£¼
return [
return []
return [t.name for t in thread_list]
return all_killed
return content if content else None
return depth
return f.read().strip()
return history_dir / f"history_{file_id}.txt"
return label
return matches
return matches[0][1]
return matches[0][1] if matches else None
return max(numbers, default=0) + 1
return name
return names
return os.path.splitext(os.path.basename(path))[0]
return pk_file_list[int(choice)]
return result.returncode, ""
return result.returncode, result.stdout + result.stderr
return selected
return sorted(glob.glob(pattern))
return text
seg, delay = pk_speak_v3._queue.get()
selected = get_value_via_fzf_or_history(key_name=key_name, file_id=file_id, options=init_options, editable=editable)
selected = selected.strip()
set_text_from_history_file("user_email", user_email)
set_text_from_history_file("user_name", user_name)
set_values_to_historical_file(f_historical=f_historical, values=init_options)
shm = shared_memory.SharedMemory(create=True, size=1, name=shm_name)
shm = shared_memory.SharedMemory(name=shm_name, create=False)
shm.buf[0] = 0  # ì´ˆê¸°ê°’ False (0)
shm.close()
shm_name = "flag_to_detect_enter"
shutil.copy2(src_path, dst_path)
shutil.move(src, dst)  # ì´ë™ ë° ì´ë¦„ ë³€ê²½
sim_mark = "âœ…" if is_similar else "  "
similarity = window_title_seg.lower() in title.lower()
sleep_seconds = 3
src = rf"{DEST_DIR}\.gitignore_for_public"
src_dir (str): Source directory.
src_path = os.path.join(root, file)
start = time.time()
start_time = time.time()
status = print_status(step_counter + 1, cmd, code, output)
stderr=subprocess.DEVNULL,
stdout=subprocess.DEVNULL,
stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, timeout=1)
step_counter += 1
step_counter = 0
steps = int(max_sec / interval)
stop_all_sounds()
str_working = remove_special_characters(text=str_working)
str_working = str(str_working).strip()
subprocess.run(
subprocess.run(['taskkill', '/PID', pid, '/T', '/F'],
subprocess.run(['taskkill', '/PID', str(pid), '/T', '/F'],
subprocess.run([name, "--version"], capture_output=True, check=True)
subprocess.run(cmd, shell=True)
survivor_hwnd = hwnds[0]
sys.exit(1)
target = get_nx(best_match_title).lower()
target = get_nx(window_title).lower()
target = os.path.splitext(os.path.basename(matches[0]))[0].lower()
target=process_queue,
target_thread = None
target_thread = thread
target_thread.join()
tasks = []
tasks.append(terminate_process_async(pid, name, f_nx))
text = text.replace(old, new)
th = proc.num_threads()
thread = threading.Thread(target=listen_enter, daemon=True)
thread.start()
thread_list = threading.enumerate()
threading.Thread(
time.sleep(interval)
timeout=1
title = win32gui.GetWindowText(hwnd)
title = win32gui.GetWindowText(hwnd).strip()
title_match = window_title.lower() in (proc.CommandLine or "").lower()
to_close = hwnds[1:]
try:
user_email = get_text_from_history_file("user_email") or ""
user_email = input("user_email=").strip()
user_name = get_text_from_history_file("user_name") or ""
user_name = input("user_name=").strip()
value = get_value_via_fzf_or_history_routine(key_name=key_name, file_id=file_id, init_options=[], editable=editable)
value = get_value_via_fzf_or_history_routine(key_name=key_name, file_id=file_id, init_options=init_options, editable=editable)
value = value or ""
values = [get_values_sanitize_for_cp949(v) for v in values]
values = get_windows_opened()
verbose (bool): If True, prints detailed info.
while 1:
while True:
whose names match those in exclude_names.
win32gui.EnumWindows(enum_handler, None)
win32gui.EnumWindows(lambda h, _: enum_handler(h, closed_hwnds), None)
win32gui.EnumWindows(lambda h, _: enum_handler(h, matched_hwnds), None)
win32gui.PostMessage(hwnd, win32con.WM_CLOSE, 0, 0)
window_opened = get_pnx_os_style(window_opened)
window_opened = get_value_via_fzf_or_history(key_name=key_name, options=values, file_id=get_file_id(key_name, func_n))
window_opened_list = get_list_sorted(working_list=window_opened_list, mode_asc=1)
window_opened_list = get_windows_opened()
window_title = get_window_title(window_title_seg)
window_title = get_window_title(window_title_seg=cmd_exe_title)
window_title = get_window_title(window_title_seg=window_title_seg)
window_title = window_title.strip()
window_title_list = get_list_sorted(working_list=window_title_list, mode_asc=1)
window_title_list = get_window_title_list()
window_title_to_kill = "pk_test.py"  # was..blank problem..
with ThreadPoolExecutor(max_workers=4) as executor:
with ThreadPoolExecutor(max_workers=min(4, len(matched_pids))) as executor:
with lock:
with open(history_file, "w", encoding="utf-8") as f_obj:
with open(history_file, encoding="utf-8") as f:
working_list = [x.strip() for x in str_working.replace(".", ",").split(",") if x.strip()]
write_like_person("exit")
}
ì£¼ì–´ì§„ cmd_exe_titleê³¼ ì¼ì¹˜í•˜ëŠ” í”„ë¡œì„¸ìŠ¤ë¥¼ ì°¾ì•„ ë™ê¸°ì ìœ¼ë¡œ ì¢…ë£Œí•˜ëŠ” í•¨ìˆ˜
ì£¼ì–´ì§„ cmd_exe_titleê³¼ ì¼ì¹˜í•˜ëŠ” í”„ë¡œì„¸ìŠ¤ë¥¼ ì°¾ì•„ ë¹„ë™ê¸°ì ìœ¼ë¡œ ì¢…ë£Œí•˜ëŠ” í•¨ìˆ˜
ì£¼ì–´ì§„ window_title_segì— í•´ë‹¹í•˜ëŠ” CMD í”„ë¡œì„¸ìŠ¤ê°€ ì¢…ë£Œë˜ì—ˆëŠ”ì§€ í™•ì¸í•˜ê³  ì¢…ë£Œ ì‹œë„.
ì°½ ì œëª©ì´ ì •í™•ížˆ ì¼ì¹˜(ë˜ëŠ” ë¶€ë¶„ ì¼ì¹˜)í•˜ëŠ” ëª¨ë“  ì°½ì— WM_CLOSE ë©”ì‹œì§€ë¥¼ ë³´ë‚´ ì°½ë§Œ ë‹«ëŠ”ë‹¤.
í”„ë¡œì„¸ìŠ¤ ê°„ ê³µìœ  ë©”ëª¨ë¦¬ë¥¼ ë‚´ë¶€ì—ì„œ ì´ˆê¸°í™”í•˜ê³  ì‚¬ìš©í•˜ë„ë¡ ë³€ê²½
í˜„ìž¬ ì‹¤í–‰ ì¤‘ì¸ ëª¨ë“  í”„ë¡œì„¸ìŠ¤ì˜ ì´ë¦„ ëª©ë¡ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
